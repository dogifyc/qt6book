(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{705:function(t,e,o){"use strict";o.r(e);var s=o(24),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"qt-for-mcus"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#qt-for-mcus"}},[t._v("#")]),t._v(" Qt for MCUs")]),t._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[t._v("Notice")]),t._v(" "),o("p",[t._v("Qt for MCUs is not a part of the open source Qt distribution, but as a commercial add-on.")])]),t._v(" "),o("p",[t._v("Qt for MCUs is a Qt version takes Qt for platforms that are too small to run Linux. Instead, Qt for MCUs can run on top of FreeRTOS, or even on the bare metal, i.e. without any operating system involved. As this book focuses on QML, we will have a deeper look at Qt Quick Ultralite and compare it to the full-size Qt offering.")]),t._v(" "),o("p",[t._v("Using Qt for MCUs you can build beautiful, fluid graphical user interfaces for your micro controller-based systems. Qt for MCUs is focused on the graphical front-end, so instead of the traditional Qt modules, common C++ types are used. This means that some interfaces change. Most notably how models are exposed to QML. In this chapter we will dive into this, and more.")])])}),[],!1,null,null,null);e.default=a.exports}}]);